// Autogenerated by hob
window.cls || (window.cls = {});
cls.Profiler || (cls.Profiler = {});
cls.Profiler["1.0"] || (cls.Profiler["1.0"] = {});

cls.Profiler["1.0"].EventList = function(arr, parent)
{
  this.parent = parent || null;
  /** 
    * May not be set if the there are no probes in the list.
    */
  this.interval = arr[0] ? new cls.Profiler["1.0"].Interval(arr[0], this) : null;
  /** 
    * List of probes. The probes are ordered according to the start time of
    * their intervals (increasing order).
    */
  var self = this;
  this.eventList = (arr[1] || []).map(function(item)
  {
    return new cls.Profiler["1.0"].Event(item, self);
  });
  this.toString = function() { return "[message EventList]"; }
};

cls.Profiler["1.0"].Interval = function(arr, parent)
{
  this.parent = parent || null;
  /** 
    * The start of the interval. If not present, this is an left-open interval.
    */
  this.start = arr[0];
  /** 
    * The end of the interval. If not present, this is an right-open interval.
    */
  this.end = arr[1];
  this.toString = function() { return "[message Interval]"; }
};

cls.Profiler["1.0"].Event = function(arr, parent)
{
  this.parent = parent || null;
  /** 
    * The type of Event. Some events carry additional information relevant
    * to their type.
    */
  // cls.Profiler["1.0"].Event.EventType
  this.type = arr[0];
  /** 
    * The time spent on this task. (Self-time). This time takes place at some
    * (unknown) point in the 'interval'.
    * 
    * Does not include 'overhead'.
    */
  this.time = arr[1];
  /** 
    * Profiling overhead. This is the time spent doing things which would
    * normally not happen if we had not been profiling, e.g. storing the
    * selector text for CSS selector Events.
    * 
    * The overhead takes place at some (unknown) point in the 'interval'.
    */
  this.overhead = arr[2];
  /** 
    * Number of hits on this Event.
    */
  this.hits = arr[3];
  /** 
    * The interval in which the Event took place. An Event may consume time
    * across multiple time slices (e.g. thread evaluation) without requiring
    * *all* the time in that interval.
    * 
    * The 'time' field contains the time actually spent working on the Event.
    * There is no exact start and end time for Events which are spread across
    * time slices, because the self-time spent is fragmented across the
    * interval.
    * 
    * We can therefore only know that the 'time' spent on this Event happened
    * some time in this interval, but not exactly where. (It would be possible
    * to expose each fragment of execution, of course, but the amount of data
    * required to represent this would be to large to handle).
    * 
    * The start of the interval represents the first time we started working on
    * this Event. The end of the interval represents the last time we were done
    * working on this Event.
    */
  this.interval = arr[4] ? new cls.Profiler["1.0"].Interval(arr[4], this) : null;
  /** 
    * The non-zero ID of this Event.
    */
  this.eventID = arr[5];
  /** 
    * The parent Event ID, or not set if this is a top-level Event.
    */
  this.parentEventID = arr[6];
  /** 
    * Aggregated 'time' for all children, including 'time' for this Event.
    */
  this.aggregatedTime = arr[7];
  /** 
    * Aggregated 'overhead' for all children, including 'overhead' for this
    * Event.
    */
  this.aggregatedOverhead = arr[8];
  /** 
    * Additional information for 'CSS_SELECTOR_MATCHING' Events.
    */
  this.cssSelectorMatching = arr[9] ? new cls.Profiler["1.0"].CssSelectorMatchingEvent(arr[9], this) : null;
  /** 
    * Additional information for 'CSS_THREAD_EVALUATION' Events.
    */
  this.threadEvaluation = arr[10] ? new cls.Profiler["1.0"].ThreadEvaluationEvent(arr[10], this) : null;
  /** 
    * Additional information for 'DOCUMENT_PARSING' Events.
    */
  this.documentParsing = arr[11] ? new cls.Profiler["1.0"].DocumentParsingEvent(arr[11], this) : null;
  /** 
    * Additional information for 'CSS_PARSING' Events.
    */
  this.cssParsing = arr[12] ? new cls.Profiler["1.0"].CssParsingEvent(arr[12], this) : null;
  /** 
    * Additional information for 'SCRIPT_COMPILATION' Events.
    */
  this.scriptCompilation = arr[13] ? new cls.Profiler["1.0"].ScriptCompilationEvent(arr[13], this) : null;
  this.toString = function() { return "[message Event]"; }
};

cls.Profiler["1.0"].CssSelectorMatchingEvent = function(arr, parent)
{
  this.parent = parent || null;
  /** 
    * The selector text, e.g. "#foo .bar".
    */
  this.selector = arr[0];
  this.toString = function() { return "[message CssSelectorMatchingEvent]"; }
};

cls.Profiler["1.0"].ThreadEvaluationEvent = function(arr, parent)
{
  this.parent = parent || null;
  /** 
    * What kind of thread the Event represents.
    */
  // cls.Profiler["1.0"].ThreadEvaluationEvent.ThreadType
  this.threadType = arr[0];
  /** 
    * If 'threadType' is 'EVENT', this field will contain the event name, e.g.
    * 'load'.
    * 
    * In all other cases, this field is not set.
    */
  this.eventName = arr[1];
  this.toString = function() { return "[message ThreadEvaluationEvent]"; }
};

cls.Profiler["1.0"].DocumentParsingEvent = function(arr, parent)
{
  this.parent = parent || null;
  /** 
    * The URL of the document that was parsed.
    */
  this.url = arr[0];
  this.toString = function() { return "[message DocumentParsingEvent]"; }
};

cls.Profiler["1.0"].CssParsingEvent = function(arr, parent)
{
  this.parent = parent || null;
  /** 
    * The URL of the stylesheet that was parsed. If the stylesheet is inlined
    * in another doucment, that document is used as the URL.
    */
  this.url = arr[0];
  this.toString = function() { return "[message CssParsingEvent]"; }
};

cls.Profiler["1.0"].ScriptCompilationEvent = function(arr, parent)
{
  this.parent = parent || null;
  /** 
    * Describes the origin of the script, for display purposes. E.g.: "inline",
    * "linked", "Browser JS", and so forth.
    */
  this.scriptType = arr[0];
  /** 
    * The URL of the stylesheet that was parsed. If the stylesheet is inlined
    * in another doucment, that document is used as the URL.
    */
  this.url = arr[1];
  this.toString = function() { return "[message ScriptCompilationEvent]"; }
};

